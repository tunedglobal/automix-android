{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PacemakerAutomix","text":"<p>Provide seamless transitions between tracks and beat-matched seek experience within your music player application on android.</p>"},{"location":"#overview","title":"Overview","text":"<p>PacemakerAutomix is a framework that exposes a player that plays music continuously in your playlist, by analyzing the tracks in your playlist to provide optimal machine-learned transitions between the tracks in the playlist as well as transitions when you seek within a track. This player can act as an automatic DJ for your music as well as making jumps in play position within tracks often feel as if no seek really ever happened.</p> <p> </p>"},{"location":"#get-started","title":"Get Started","text":""},{"location":"#install-the-sdk","title":"Install the SDK","text":""},{"location":"#requirements","title":"Requirements","text":"<p>This library requires minimum Android SDK Level 21, Android 5 Lollipop.</p>"},{"location":"#importing-artifact","title":"Importing artifact","text":"<p>PacemakerAutomix can be brougth into your project via maven our maven private repository.</p> <p>Step 1: Add the Tuned Global's maven repository to the list of dependencies</p> <p>On your settings.gradle.kts, add the Tuned Global's maven repository:</p> <pre><code>dependencyResolutionManagement {\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     repositories {\n         // ...\n         maven {\n             url = uri(\"http://tgpm-maven-repo.s3-website-us-west-2.amazonaws.com/releases\")\n             isAllowInsecureProtocol = true\n         }\n         // ...\n     }\n}\n</code></pre> <p>Step 2: Add the dependency to your target</p> <p>In your build.gradle.kts file, add the P\u00c5acemakerAutomix library:</p> <pre><code>  // ...\n  implementation(\"com.tunedglobal:automix-sdk:0.2.0\")\n  // ...\n</code></pre> <p>Step 3: Add the required Proguard rules for this library</p> <p>In your proguard-rules.pro file, add the following:</p> <pre><code>-keep class com.tunedglobal.automix.logic.cpp.AMJNILib {\n    public static *;\n    public *;\n}\n</code></pre> <p>Step 4: You can now use the PacemakerAutomix library</p> <pre><code>  // ...\n  import com.tunedglobal.automix.*\n  // ...\n</code></pre>"},{"location":"#configure-the-sdk","title":"Configure the SDK","text":""},{"location":"#initialize-with-tuned","title":"Initialize with Tuned","text":"<p>In order to initialize PacemakerAutomix against Tuned Global's APIs and services you need a TunedRestDelegate and a AutomixSDKStatusObserverDelegate, plus a store ID, applicationId and a country code.</p> <pre><code>override fun onStart(arguments: Bundle?) {\n    // ...\n\n    val applicationContext: ApplicationContext = myApplicationContext\n    val tunedRestDelegate: TunedRestDelegate = myTunedRestDelegate\n    val automixSDKStatusObserverDelegate: AutomixSDKStatusObserverDelegate = myAutomixSDKStatusObserverDelegate\n    val countryCode: String = myCountryCode // \"US\" ? \"AU\"?\n    val storeId: String = myTunedStoreId\n    val applicationId: String = myApplicationId\n    AutomixSDK.initialize(applicationContext,\n                          tunedRestDelegate,\n                          automixSDKStatusObserverDelegate,\n                          countryCode,\n                          storeId,\n                          applicationId) { error -&gt;\n        if (error != null) {\n            // This means you are fobidden to use the Automix SDK or you have no internet connection.\n            return\n        }\n        // The Automix SDK public functions can be used from this point onwards :)\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"#tunedrestdelegate","title":"TunedRestDelegate","text":"<ul> <li>PacemakerAutomix requires your client's access &amp; refresh tokens in order to take over playback, provided via TunedRestDelegate/tunedRestTokenExpired(deviceIdentifierForVendor:                                           countryCode:                                           tunedUserId:                                           oldAccessToken:                                           refreshToken:                                           tokenType:                                           completion:)</li> </ul> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun tunedRestTokenExpired(deviceIdentifierForVendor: String,\n                                       countryCode: String,\n                                       tunedUserId: String?,\n                                       oldAccessToken: String?,\n                                       refreshToken: String?,\n                                       tokenType: String?,\n                                       completion: (AutomixSDKError?, TunedAuthenticationResponse?, String?) -&gt; Unit)\n    {\n        val response: TunedAuthenticationResponse = TunedAuthenticationResponse.init()\n        response.access_token = myAccessToken\n        response.token_type = myTokenType\n        response.expires_in = myTokenExpiresIn\n        response.refresh_token = myRefreshToken\n        response.tuned_user_id = myTunedUserId\n        completion(response, null)\n    }\n    // ...\n}\n</code></pre> <ul> <li>PacemakerAutomix requires your client's authenticated device, provided via TunedRestDelegate/asyncGetAuthenticatedDevice(deviceIdentifierForVendor:completion:)</li> </ul> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun asyncGetAuthenticatedDevice(\n            deviceIdentifierForVendor: String,\n            completion: (AutomixSDKError?, String?) -&gt; Unit)\n    {\n        // ...\n        val myTunedDeviceId: String = tunedDeviceId\n        completion(null, myTunedDeviceId)\n        return\n    }\n    // ...\n}\n</code></pre> <ul> <li>This delegate also provides hooks to inject cached track audio data and metadata, to shortcut for efficiency and prevent PacemakerAutomix from querying audio data and metadata to Tuned Global's APIs if they are already available. This also enables offline playback when all required data is available on device. This is done via TunedRestDelegate/syncGetTrackMetadata(trackId:)</li> </ul> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun syncGetTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If I have this track cached, I should be able to tell its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.metadataForTrack(trackId)\n    }\n\n    override fun syncIsTrackExplicit(trackId: String?): Boolean? {\n        // If I have this track cached, I should be able to tell if its lyrics are explicit\n        return this.isTrackExplicit(trackId)\n    }\n    // ...\n}\n</code></pre> <p>and TunedRestDelegate/syncGetCachedTrack(trackId:)</p> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If I have this track cached, I should be able to decrypt it and send the data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>PacemakerAutomix will download the tracks it needs to play when they are not provided frtom your cache. It will do so lazizly (as playback or analysis requires). When a track finished downloading, PacemakerAutomix will pass the audio data for you to cache if you need it. This is done via  TunedRestDelegate/tunedTrackFinishedDownloading(trackId:data:)</li> </ul> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun tunedTrackFinishedDownloading(trackId: String, data: ByteArray) {\n        // Automix SDK finished downloading a track. If I have offline playback or encrypted cache capabilities I should act accordingly here\n        return this.cacheTrack(trackId, data)\n    }\n    // ...\n}\n</code></pre> <ul> <li>Should you need access to the PacemakerAutomix log in order to debug your implementation, you can print its output via this delegate as well. You can do that via  TunedRestDelegate/logAutomixSDKDebugMessage(logLevel:message:)</li> </ul> <pre><code>public class MyTunedRestDelegate: TunedRestDelegate {\n    // ...\n    override fun logAutomixSDKDebugMessage(logLevel:Int, message: String) {\n        val logTag = \"AutomixSDK\"\n        when(logLevel) {\n            Log.ASSERT -&gt; { Log.e(logTag, message) }\n            Log.DEBUG -&gt;  { Log.d(logTag, message) }\n            Log.ERROR -&gt;  { Log.e(logTag, message) }\n            Log.INFO -&gt;  { Log.i(logTag, message) }\n            Log.VERBOSE -&gt;  { Log.v(logTag, message) }\n            Log.WARN -&gt;  { Log.w(logTag, message) }\n        }\n    }\n    // ...\n}\n</code></pre>"},{"location":"#initialize-with-custom-backend","title":"Initialize with Custom backend","text":"<p>In order to initialize PacemakerAutomix when you take the responsability of providing audio data and metadata you need a AutomixSDKStreamingDelegate and a AutomixSDKStatusObserverDelegate, plus a store ID, applicationId and a country code.</p> <pre><code>override fun onStart(arguments: Bundle?) {\n    // ...\n\n    val applicationContext: ApplicationContext = myApplicationContext\n    val automixSDKStreamingDelegate: AutomixSDKStreamingDelegate = myAutomixSDKStreamingDelegate\n    val automixSDKStatusObserverDelegate: AutomixSDKStatusObserverDelegate = myAutomixSDKStatusObserverDelegate\n    val countryCode: String = myCountryCode // \"US\" ? \"AU\"?\n    val storeId: String = myTunedStoreId\n    val applicationId: String = myApplicationId\n    AutomixSDK.initialize(applicationContext,\n                          automixSDKStreamingDelegate,\n                          automixSDKStatusObserverDelegate,\n                          countryCode,\n                          storeId,\n                          applicationId) { error -&gt;\n        if (error != null) {\n            // This means you are fobidden to use the Automix SDK or you have no internet connection.\n            return\n        }\n        // The Automix SDK public functions can be used from this point onwards :)\n    }\n\n    // ...\n}\n</code></pre>"},{"location":"#automixsdkstreamingdelegate","title":"AutomixSDKStreamingDelegate","text":"<ul> <li>If your custom backend puts fetching metadata and track data behing a login, PacemakerAutomix needs to know if the user in your aspplication is logged in or not via AutomixSDKStreamingDelegate/isLoggedIn()</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun isLoggedIn() {\n        return this.loggedIn\n    }\n    // ...\n}\n</code></pre> <ul> <li>If your custom backend only allows playback on a device under certain conditions (for instance in only allows one device to play at any given time), PacemakerAutomix needs to know if a device is allowed to play via AutomixSDKStreamingDelegate/asyncCheckDeviceStatus(completion:)</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun asyncCheckDeviceStatus(completion: (AutomixSDKError?, Boolean) -&gt; Unit) {\n        this.canDeviceContinuePlaying() { allowedToPlay -&gt;\n            return allowedToPlay\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>PacemakerAutomix requires devices to have a unique identifier, provided via AutomixSDKStreamingDelegate/getDeviceIdentifier()</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun getDeviceIdentifier(): String? {\n        return this.deviceIdentifier\n    }\n    // ...\n}\n</code></pre> <ul> <li>This delegate also provides hooks to inject cached track audio data and metadata, to shortcut for efficiency and prevent PacemakerAutomix from querying audio data and metadata to your custom backend if they are already available. This also enables offline playback when all required data is available on device. This is done via <code>AutomixSDKStreamingDelegate/syncGetTrackMetadata(trackId:)</code></li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun asyncGetTrackMetadata(trackId: String, completion: (AutomixSDKError?, AutomixSDKTrackModel?) -&gt; Unit) {\n        // If I have this track cached, I should be able to tell its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.metadataForTrack(trackId)\n    }\n\n    override fun syncIsTrackExplicit(trackId: String?): Boolean? {\n        // If I have this track cached, I should be able to tell if its lyrics are explicit\n        return this.isTrackExplicit(trackId)\n    }\n    // ...\n}\n</code></pre> <p>and AutomixSDKStreamingDelegate/syncGetCachedTrack(trackId:)</p> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If I have this track cached, I should be able to decrypt it and send the data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>At any time, when track metadata is available, this delegate can store for later use via AutomixSDKStreamingDelegate/cacheMetadata(_:)`</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun cacheMetadata(metadata: List&lt;AutomixSDKTrackModel&gt;) {\n        this.metadataForTrack[metadata.trackId] = metadata\n    }\n    // ...\n}\n</code></pre> <ul> <li>PacemakerAutomix will download the trackmetadata as it needs it. When Pacemaker requires to download track metadata, it will do so via AutomixSDKStreamingDelegate/asyncGetTrackMetadata(trackId:completion:)``</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun asyncGetTrackMetadata(trackId: String, completion: (AutomixSDKError?, AutomixSDKTrackModel?) -&gt; Unit) {\n        this.getTrackMetadata(trackId) { error, trackMetadata -&gt;\n            val automixSDKTrackModel = translateMetadata(trackMetadata)\n            completion(error, automixSDKTrackModel)\n            return@getTrackMetadata\n        }\n    }\n\n    override fun asyncIsTrackExplicit(trackId: String, completion: (AutomixSDKError?, Boolean) -&gt; Unit) {\n        this.isTrackExplicit(trackId) { error, isTrackExplicit -&gt;\n            completion(error, isTrackExplicit)\n            return@isTrackExplicit\n        }\n    }\n\n    // ...\n}\n</code></pre> <ul> <li>When PacemakerAutomix needs to download a track, it will ask for the url for it. It supports sessionID if you want urls to expire and return 403s. It will do so via AutomixSDKStreamingDelegate/asyncGetStream(streamingDeviceId:sessionId:trackId:completion:)</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun asyncGetStream(streamingDeviceId: String, sessionId: String, trackId: String, completion: (AutomixSDKError?, String?, String?, AutomixSDKReportingURLSet?) -&gt; Unit) {\n        this.getTrackURL(streamingDeviceId, sessionId, trackId) { error, url -&gt;\n            completion(error, url)\n            return@getTrackURL\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>PacemakerAutomix will log playback events while playing your content. It will do so via AutomixSDKStreamingDelegate/asyncLogPlayEvent(trackId:seconds:guid:logPlayType:completion:)``</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun asyncLogPlayEvent(trackId: String, seconds: Int, guid: String, logPlayType: String, completion: (Boolean) -&gt; Unit) {\n        this.logPlaybackEvent(trackId, seconds, guid, logPlayType) { error -&gt;\n            completion(error == null)\n            return@logPlaybackEvent\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>When a track finished downloading, PacemakerAutomix will pass the audio data for you to cache if you need it. This is done via  AutomixSDKStreamingDelegate/trackCompletedDownload(trackId:data:)``</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun trackCompletedDownload(trackId: String, data: ByteArray) {\n        this.cacheTrack(trackId, data)\n    }\n    // ...\n}\n</code></pre> <ul> <li>As a track is being downloaded, PacemakerAutomix will report download progress via AutomixSDKStreamingDelegate/trackBufferingProgress(trackId:progress:)``</li> </ul> <pre><code>public class MyAutomixSDKStreamingDelegate: AutomixSDKStreamingDelegate {\n    // ...\n    override fun trackBufferingProgress(trackId: String, progress: Float) {\n        this.updateTrackDownloadProgress(trackId, progress)\n    }\n    // ...\n}\n</code></pre> <p>Do keep in mind this download is done lazily, as PacemakerAutomix requires data for analysis / playback. There is no guarantee a track will download in its entirety if the track is not played in its entirety.</p> <ul> <li> <p>PacermakerAutomix will soon provide support to display and download artwork, and display track recommendations. As of today, these delegate functions are usued so they can be left unimplemented.</p> <ul> <li>AutomixSDKStreamingDelegate/asyncGetThumborLocation(completion:)</li> <li>AutomixSDKStreamingDelegate/asyncGetTrackRecommendations(identifiers:limit:completion:)</li> </ul> </li> </ul>"},{"location":"#automixsdkstatusobserverdelegate","title":"AutomixSDKStatusObserverDelegate","text":"<p>The AutomixSDKStatusObserverDelegate is responsible for updating your player's UI, please refer to \"Update UI\"</p>"},{"location":"#check-if-initialized","title":"Check if initialized","text":"<p>To check wether PacemakerAutomix is currently initialized, use AutomixSDK/initialized()</p>"},{"location":"#turn-automix-on-and-off","title":"Turn Automix on and off","text":"<p>PacemakerAutomix's player can be started and stopped. When it is started, it will take over any other player and start playing the tracks it is fed, and therefore any other player should be at that time paused. When it is stopped, PacemakerAutomix's player will stop rendering audio and so any other player can be resumed.</p>"},{"location":"#turn-automix-on","title":"Turn Automix on","text":"<p>When PacemakerAutomix's player is started, it takes over the application's Audio Session and sets it up at a sample rate of 44100, categoy \".playback\", IOBufferDuration of ~0.006 and 2 output channels (stereo).</p> <p>To start the player, use either AutomixSDK/automixOn(completion:) to start it with no content (and wait for content to be provided via the playback control methods, see \"Control playback\"</p> <pre><code>    // ...\n    AutomixSDK.getInstance()?.automixOn { error -&gt;\n        if (error != null) {\n            // Something went wrong, playback did not start\n            return\n        }\n        this.started = true\n        // We are now waiting for content.\n        // ...\n    }\n\n    // ...\n</code></pre> <p>, or AutomixSDK/automixOn(identifiers:metadata:playTrackIndex:seconds:autoplay:contextType:contextId:completion:) to start it with the content provided in the method signature,</p> <pre><code>    // ...\n\n    val electronicMusicPlaylist = listOf(\"116484855\",\"66906273\",\"120584575\",\"116887896\")\n    val cachedMetadata = listOf(trackMetadata1, trackMetadata2, trackMetadata3, trackMetadata4)\n    AutomixSDK.instance.automixOn(electronicMusicPlaylist,\n                                  cachedMetadata,\n                                  playTrackIndex=0, seconds=0, autoplay=true,\n                                  contextType=\"playlist\", contextId=\"some-playlist-id\") { error -&gt;\n        if (error != null) {\n            // Something went wrong, playback did not start\n            return\n        }\n        this.started = true\n        // We are now playing content.\n        // ...\n    }\n\n    // ...\n</code></pre>"},{"location":"#turn-automix-off","title":"Turn Automix off","text":"<p>When stopped, PacemakerAutomix restores the AVAudioSession with the settings it found when starting.  To stop the player, use AutomixSDK/automixOff(completion:)</p> <pre><code>    // ...\n\n    AutomixSDK.getInstance()?.automixOff { error, status -&gt;\n        if (error != null) {\n            // Something went wrong, playback did not stop\n            return\n        }\n        this.started = false\n        // We are no longer playing.\n        // ...\n    }\n\n    // ...\n</code></pre> <p>This function reports the status of pacemakerAutomix at the time it was stopped, in case you want to have another player pick up playback where PacemakerAutomix left it. See AutomixSDKStatusObserverDelegate.</p>"},{"location":"#check-if-on","title":"Check if on","text":"<p>To check wether PacemakerAutomix is currently on, use AutomixSDK/on()</p>"},{"location":"#control-playback","title":"Control playback","text":"<p>In order to use playback controls, PacemakerAutomix needs to be Initialized and On. Please see \"Configure the SDK\".</p> <p>Use the AutomixSDK singleton to control playback of the mix. Actions supported are:</p> <ul> <li>AutomixSDK/resetMixToEmpty(completion:)</li> <li>AutomixSDK/loadTracks(identifiers:metadata:playTrackIndex:seconds:autoplay:contextType:contextId:completion:)</li> <li>AutomixSDK/addTrack(identifier:metadata:index:completion:)</li> <li>AutomixSDK/addTracks(identifiers:metadata:index:completion:)</li> <li>AutomixSDK/removeTrack(at:completion:)</li> <li>AutomixSDK/moveTrack(at:toIndex:completion:)</li> <li>AutomixSDK/play(completion:)</li> <li>AutomixSDK/pause(completion:)</li> <li>AutomixSDK/next(completion:)</li> <li>AutomixSDK/previous(completion:)</li> <li>AutomixSDK/back(completion:)</li> <li>AutomixSDK/seekTo(seconds:completion:)</li> <li>AutomixSDK/skipToTrackAtIndex(_:completion:)</li> <li>AutomixSDK/reorderTracks(newOrder:completion:)</li> <li>AutomixSDK/playTrackUntilEndThenPause(completion:)</li> <li>AutomixSDK/resetMixToEmpty(completion:)`</li> <li>AutomixSDK/loopPlayingTrack(completion:)`</li> <li>AutomixSDK/stopLoopingPlayingTrack(completion:)`</li> </ul>"},{"location":"#player-settings","title":"Player settings","text":"<ul> <li>AutomixSDK/setAutomixTempoNormalised(_:completion:)</li> <li>AutomixSDK/setAutomixPlaySpeed(_:completion:)</li> <li>AutomixSDK/setMute(on:completion:)</li> <li>AutomixSDK/setReplay(on:completion:)</li> <li>AutomixSDK/setVinylStartStopEnabled(_:completion:)</li> <li>AutomixSDK/setAutomixVolumeNormalised(_:completion:)</li> <li>AutomixSDK/setPreferredTransitionDurationSeconds(_:completion:)</li> </ul>"},{"location":"#explicit-lyrics-filtering","title":"Explicit lyrics filtering","text":"<ul> <li>AutomixSDK/setFilterExplicit(filterExplicit:completion:)</li> </ul>"},{"location":"#update-ui","title":"Update UI","text":""},{"location":"#receive-status-updates","title":"Receive status updates","text":"<p>PacemakerAutomix reports its state via AutomixSDKStatusObserverDelegate. This delegate reports the status via its statusChanged method every time the status changed, and in the function it specifies the current status and the variables that were altered since the last time an update was issued. Use the status variables to update the content of your player UI.</p> <pre><code>public class MyPlayer: AutomixSDKStatusObserverDelegate {\n    // ...\n\n    var latestStatus: AutomixSDKStatus? = null\n    override fun statusChanged(variables: List&lt;String&gt;, status: AutomixSDKStatus) {\n        this.latestStatus = status\n        for (property in variables) {    \n            when (property) {\n            when (property) {\n                \"playing\" -&gt; {\n                    this.playing = status.playing\n                    val playButton = findViewById&lt;View&gt;(R.id.playButton) as Button\n                    playButton.text = if(this.playing) \"Pause\" else \"Play\"\n                }\n                \"mixing\" -&gt; {}\n                \"playingTrackIdentifier\" -&gt; {}\n                \"playingTrackIndex\" -&gt; {}\n                \"playingTrackCurrentTime\" -&gt; {\n                    val ellapsedLabel = findViewById&lt;View&gt;(R.id.ellapsedLabel) as TextView\n                    val remainingLabel = findViewById&lt;View&gt;(R.id.remainingLabel) as TextView\n                    val ellapsedTimeString = this.timeString(status.playingTrackCurrentTime.toInt())\n                    val remainingTimeString = this.timeString((status.playingTrackTotalTime - status.playingTrackCurrentTime).toInt())\n                    ellapsedLabel.text = ellapsedTimeString\n                    remainingLabel.text = remainingTimeString\n                    val seekSlider = findViewById&lt;View&gt;(R.id.seekSlider) as SeekBar\n                    seekSlider.progress = (status.playingTrackCurrentTime/status.playingTrackTotalTime*1000).toInt()\n                }\n                \"playingTrackStreamingProgress\" -&gt; {}\n                \"playingTrackCurrentTimeInternal\" -&gt; {}\n                \"playingTrackTotalTime\" -&gt; {\n                    val remainingLabel = findViewById&lt;View&gt;(R.id.remainingLabel) as TextView\n                    remainingLabel.text = this.timeString((status.playingTrackTotalTime - status.playingTrackCurrentTime).toInt())\n                    val seekSlider = findViewById&lt;View&gt;(R.id.seekSlider) as SeekBar\n                    seekSlider.progress = (status.playingTrackCurrentTime/status.playingTrackTotalTime*1000).toInt()\n                }\n                \"canSkipToPrevious\" -&gt; {\n                    val previousButton = findViewById&lt;View&gt;(R.id.previousButton) as Button\n                    setViewsEnabled(status.canSkipToPrevious, listOf(previousButton))\n                }\n                \"canSkipToNext\" -&gt; {\n                    val nextButton = findViewById&lt;View&gt;(R.id.nextButton) as Button\n                    setViewsEnabled(status.canSkipToNext, listOf(nextButton))\n                }\n                \"canBack\" -&gt; {}\n                \"canPlayPause\" -&gt; {\n                    val playButton = findViewById&lt;View&gt;(R.id.playButton) as Button\n                    val loopTrackButton = findViewById&lt;View&gt;(R.id.loopTrackButton) as Button\n                    setViewsEnabled(status.canPlayPause, listOf(playButton, loopTrackButton))\n                }\n                \"canSeek\" -&gt; {\n                    val seekSlider = findViewById&lt;View&gt;(R.id.seekSlider) as SeekBar\n                    setViewsEnabled(status.canSeek, listOf(seekSlider))\n                }\n                \"canReorderTracks\" -&gt; {\n                    val shuffleButton = findViewById&lt;View&gt;(R.id.shuffleButton) as Button\n                    setViewsEnabled(status.canReorderTracks, listOf(shuffleButton))\n                }\n                \"replayOn\" -&gt; {\n                    val repeatButton = findViewById&lt;View&gt;(R.id.repeatButton) as Button\n                    if(status.replayOn) {\n                        repeatButton.setTextColor(Color.GREEN)\n                    } else {\n                        repeatButton.setTextColor(Color.WHITE)\n                    }\n                }\n                \"readyToPlay\" -&gt; {}\n                \"canMixNow\" -&gt; {}\n                \"playlist\" -&gt; {}\n                \"muted\" -&gt; {\n                    val muteButton = findViewById&lt;View&gt;(R.id.muteButton) as Button\n                    val text = if(status.muted) \"Unmute\" else \"Mute\"\n                    muteButton.text = text\n                }\n                \"masterTempoNormalized\" -&gt; {\n                    val tempoSlider = findViewById&lt;View&gt;(R.id.tempoSlider) as SeekBar\n                    tempoSlider.progress = (status.masterTempoNormalized*1000).toInt()\n                }\n                \"playSpeed\" -&gt; {}\n                \"normalisedVolume\" -&gt; {\n                    val volumeSlider = findViewById&lt;View&gt;(R.id.volumeSlider) as SeekBar\n                    volumeSlider.progress = (status.normalisedVolume*1000).toInt()\n                }\n                \"preferredTransitionDurationSeconds\" -&gt; {}\n                \"requestedLoopTrackIdentifier\" -&gt; {\n                    this.loopingTrack = status.requestedLoopTrackIdentifier != null\n                    val title = if(this.loopingTrack) \"Loop track Off\" else \"Loop track On\"\n                    val loopTrackButton = findViewById&lt;View&gt;(R.id.loopTrackButton) as Button\n                    loopTrackButton.text = title\n                }\n                \"vinylStartStop\" -&gt; {}\n                \"nextTransitionDuration\" -&gt; {}\n                \"transitionStartTimeSeconds\" -&gt; {}\n                \"failedTrackLoadIdentifiers\" -&gt; {}\n                \"canOnOff\" -&gt; {}\n                \"mixEndedAndPaused\" -&gt; {}\n            }\n        }\n    }\n\n\n    // ...\n}\n</code></pre>"},{"location":"#receive-playback-events","title":"Receive playback events","text":"<p>When a playback event happens, Pacemaker Automix calls the status observer delegate method:</p> <pre><code>public class MyPlayer: AutomixSDKStatusObserverDelegate {\n    // ...\n\n    override fun playbackEvent(type: AutomixSDKPlaybackEventType, identifier: String?, status: AutomixSDKStatus?) {\n        when (type) {\n            AutomixSDKPlaybackEventType.trackPlayStart -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayPlayed5Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayHeartbeat30Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayStopped -&gt; {}\n            AutomixSDKPlaybackEventType.mixPlaybackEnded -&gt; {}\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>The type of playback event is modelled by the enum AutomixSDKPlaybackEventType.</p>"},{"location":"#automix-status","title":"Automix Status","text":"<p>The status of PacemakerAutomix is modelled by AutomixSDKStatus.</p>"},{"location":"#errors","title":"Errors","text":"<p>Find the enumeration describing errors this SDK can emmit here.</p>"},{"location":"#data-models","title":"Data models","text":"<p>How is data passed to and from the PacemakerAutomix player</p> <ul> <li>AutomixSDKStatus</li> <li>AutomixSDKTrackModel</li> <li>AutomixSDKArtistModel</li> <li>AutomixSDKPluginMetadataDictionaryEntryModel</li> <li>AutomixSDKReportingURLSet</li> <li>TunedAuthenticationResponse</li> </ul>"},{"location":"#data-persistance","title":"Data persistance","text":""},{"location":"#music-metadata-database","title":"Music Metadata Database","text":"<p>In the Caches Directory, PacemakerAutomix keeps a light weight sql database to store the metadata of tracks that have been played for subsequent lookup. This file is called \"music.db\" and if deleted will be recreated on launch.</p>"},{"location":"#music-analysis-database","title":"Music Analysis Database","text":"<p>In the Caches Directory, PacemakerAutomix keeps a light weight sql database to store the analysis data of tracks that have been played for subsequent lookup. This analysis is required to produce beat-matched transitions. This file is called \"paralysis.db\" and if deleted will be recreated on launch.</p>"},{"location":"#playback-log","title":"Playback Log","text":"<p>PacemakerAutomix stores offline playback logs for subsequent reporting on a Core Data database.</p>"},{"location":"#transition-playback-log","title":"Transition Playback Log","text":"<p>PacemakerAutomix stores offline transition playback logs for subsequent reporting on a Core Data database.</p>"},{"location":"#clearing-the-cache","title":"Clearing the cache","text":"<p>PacemakerAutomix provides a function to reset persistent analysis storage by calling AutomixSDK/clearCache()</p>"},{"location":"#api-reference","title":"API Reference","text":"<p>Find the documentation of available APIs here: PacemakerAutomix</p>"},{"location":"#change-log","title":"Change Log","text":"<p>This is a dev build - No change log available.</p>"}]}