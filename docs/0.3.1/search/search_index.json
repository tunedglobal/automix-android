{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutomixIQ","text":"<p>Provide seamless transitions between tracks and beat-matched seek experience within your music player application on Android.</p>"},{"location":"#overview","title":"Overview","text":"<p>AutomixIQ is a framework that exposes a player that plays music continuously in your playlist, by analyzing the tracks in your playlist to provide optimal machine-learned transitions between the tracks in the playlist as well as transitions when you seek within a track. This player can act as an automatic DJ for your music as well as making jumps in play position within tracks often feel as if no seek really ever happened.</p> <p> </p>"},{"location":"API-reference/","title":"API Reference","text":"<p>Find the documentation of available APIs here: AutomixIQ API Reference</p>"},{"location":"Change-log/","title":"Change Log","text":"<p>This is a dev build - No change log available.</p>"},{"location":"Configure-the-SDK/","title":"Configure the SDK","text":"<p>AutomixIQ is compatible with Tuned Global's API and any custom backend. Please refer to the following sections based on your chosen backend.</p>"},{"location":"Configure-the-SDK/#initialise-with-tuned","title":"Initialise with Tuned","text":"<p>In order to initialise AutomixIQ against Tuned Global's APIs and services, you need a store ID, application ID provided by Tuned team and implement an instance of the TunedRestHook interface. We suggest initialise the SDK when your music service is up and running.</p> <pre><code>override fun onStart(arguments: Bundle?) {\n    // ...\n\n    val applicationContext: ApplicationContext = myApplicationContext\n    val tunedRestHook: TunedRestHook = myTunedRestHook\n\n    val countryCode: String = myCountryISO2Code // \"US\" ? \"AU\"?\n    val storeId: String = myTunedStoreId\n    val applicationId: String = myApplicationId\n    val config = AutomixSDKConfig.Builder().country(countryCode).storeId(storeId).applicationId(applicationId).logLevel(4).build()\n\n    AutomixSDK.initialise(applicationContext,\n                          tunedRestHook,\n                          config,\n                          onComplete = \n    { _ -&gt; \n         // The Automix SDK public functions can be used from this point onwards :)\n\n         // We can add a status listener to get UI updates and play events\n         val automixSDKStatusListener: AutomixSDKStatusListener = myAutomixSDKStatusListener\n         AutomixSDK.getInstance()?.addStatusListener(automixSDKStatusListener)\n\n         // We can add a cahed music provider if we want to support offline playback\n         val cachedMusicProvider: AutomixSDKCachedMusicProvider = myCachedMusicProvider\n         AutomixSDK.getInstance()?.setCachedMusicProvider(AutomixSDKCachedMusicProviderImpl(musicPlayerFacade, player, crypto))\n\n         // ...\n    }, onError = { error, _ -&gt; \n         // This means you are fobidden to use the Automix SDK or you have no internet connection.\n         return\n    })\n\n    // ...\n}\n</code></pre>"},{"location":"Configure-the-SDK/#implementing-an-instance-of-tunedresthook","title":"Implementing an instance of TunedRestHook","text":"<ul> <li>AutomixIQ requires your client's access &amp; refresh tokens in order to take over playback. To provide them, implement tunedRestTokenExpired method and return the token by invoking the onComplete function.</li> </ul> <pre><code>public class MyTunedRestHook: TunedRestHook {\n    // ...\n    override fun tunedRestTokenExpired(deviceIdentifierForVendor: String,\n                                       countryCode: String,\n                                       tunedUserId: String?,\n                                       oldAccessToken: String?,\n                                       refreshToken: String?,\n                                       tokenType: String?,\n                                       onComplete: ((TunedAuthenticationResponse?, String) -&gt; Unit)?,\n                                       onError: ((AutomixSDKError) -&gt; Unit)?) {\n    this.getNewCredentials(onComplete = { myAccessToken, myTokenType, myTokenExpiresIn, myRefreshToken, myTunedUserId -&gt;\n        val response: TunedAuthenticationResponse = TunedAuthenticationResponse.init()\n        response.access_token = myAccessToken\n        response.token_type = myTokenType\n        response.expires_in = myTokenExpiresIn\n        response.refresh_token = myRefreshToken\n        response.tuned_user_id = myTunedUserId\n        onComplete(response, null)\n    }, onError = { error -&gt;\n        // ...\n        onError(error)\n    })\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ needs to know if it is allowed to automatically register a new device with Tuned backend or if you will provide an already existing one. To let it know, implement providesAuthenticatedDevice.</li> </ul> <pre><code>public class MyTunedRestHook: TunedRestHook {\n    // ...\n    fun providesAuthenticatedDevice(): Boolean {\n        return true // false?\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ requires your client's authenticated device id, implement asyncGetAuthenticatedDevice method and return the id by invoking the onComplete function.</li> </ul> <pre><code>public class MyTunedRestHook: TunedRestHook {\n    // ...\n    fun asyncGetAuthenticatedDevice(deviceIdentifierForVendor: String,\n                                        onComplete: ((String) -&gt; Unit)?,\n                                        onError: ((AutomixSDKError) -&gt; Unit)?)\n    {\n        // ...\n        val myTunedDeviceId: String = tunedDeviceId\n        onComplete(null, myTunedDeviceId)\n        return\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ requires a unique identifier for the device using it, to provide it implement uniqueDeviceIdentifier.</li> </ul> <pre><code>public class MyTunedRestHook: TunedRestHook {\n    // ...\n    fun uniqueDeviceIdentifier(): String\n    {\n        // ...\n        val udi: String = myUniqueDeviceIdentifier\n        return udi\n    }\n    // ...\n}\n</code></pre>"},{"location":"Configure-the-SDK/#implementing-an-instance-of-automixsdkcachedmusicprovider-optional","title":"Implementing an instance of AutomixSDKCachedMusicProvider (Optional)","text":"<p>AutomixIQ can be used for offline playback using cached music data. AutomixSDKCachedMusicProvider provides hooks to inject cached track audio data and metadata, to shortcut for efficiency and prevent AutomixIQ from querying audio data and metadata to Tuned Global's APIs if they are already available. This also enables offline playback when all required data is available on device. Implement the AutomixSDKCachedMusicProvider and add it to the SDK after initialise.</p> <pre><code>AutomixSDK.getInstance()?.setCachedMusicProvider(MyCachedMusicProvider())\n</code></pre> <ul> <li>You can provide track metadata in syncGetTrackMetadata() if you do not pass in track metadata when loading new tracks to AutomixIQ. For offline playback, this is required.</li> </ul> <pre><code>public class MyCachedMusicProvider: AutomixSDKCachedMusicProvider {\n    // ...\n    override fun syncGetTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If I have this track cached, I should be able to tell its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.metadataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>You can provide the audio byte data of the audio file in syncGetCachedTrack(). For offline playback, this is required.</li> </ul> <pre><code>public class MyCachedMusicProvider: AutomixSDKCachedMusicProvider {\n    // ...\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If I have this track cached, I should be able to decrypt it and send the data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ will download the tracks it needs to play when they are not provided from your cache. It will do so lazily (as playback or analysis requires). When a track finished downloading, AutomixIQ will pass the audio byte data for you to save on local storage.</li> </ul> <pre><code>public class MyCachedMusicProvider: AutomixSDKCachedMusicProvider {\n    // ...\n    override fun trackFinishedDownloading(trackId: String, data: ByteArray) {\n        // Automix SDK finished downloading a track. If I have offline playback or encrypted cache capabilities I should act accordingly here\n        return this.cacheTrack(trackId, data)\n    }\n    // ...\n}\n</code></pre> <ul> <li>You can also monitor the download progress.</li> </ul> <pre><code>public class MyCachedMusicProvider: AutomixSDKCachedMusicProvider {\n    // ...\n    override fun trackBufferingProgress(trackId: String, progress: Float {\n        // Update your UI here\n        this.updateTrackBufferingProgress(trackId, progress)\n    }\n    // ...\n}\n</code></pre>"},{"location":"Configure-the-SDK/#initialise-with-custom-backend","title":"Initialise with Custom backend","text":"<p>In order to initialise AutomixIQ when you take the responsability of providing audio data and metadata you need the application context, a AutomixSDKStreamingListener, plus a store ID, applicationId and a country code.</p> <pre><code>override fun onStart(arguments: Bundle?) {\n    // ...\n\n    val applicationContext: ApplicationContext = myApplicationContext\n    val automixSDKStreamingListener: AutomixSDKStreamingListener = myAutomixSDKStreamingListener\n\n    val countryCode: String = myCountryCode // \"US\" ? \"AU\"?\n    val storeId: String = myTunedStoreId\n    val applicationId: String = myApplicationId\n    val config = AutomixSDKConfig.Builder().country(countryCode).storeId(storeId).applicationId(applicationId).logLevel(4).build()\n\n    AutomixSDK.initialise(applicationContext,\n                          automixSDKStreamingListener,\n                          config,\n                          onComplete = \n    { _ -&gt; \n        // The Automix SDK public functions can be used from this point onwards :)\n\n        // We can add a status listener to get UI updates and play events\n        val automixSDKStatusListener: AutomixSDKStatusListener = myAutomixSDKStatusListener\n        AutomixSDK.getInstance()?.addStatusListener(automixSDKStatusListener)\n\n        // ...\n    }, onError = { error, _ -&gt;\n        // This means you are fobidden to use the Automix SDK or you have no internet connection.\n    })\n\n    // ...\n}\n</code></pre>"},{"location":"Configure-the-SDK/#implementing-an-instance-of-automixsdkstreaminglistener","title":"Implementing an instance of AutomixSDKStreamingListener","text":"<p>AutomixSDKStreamingListener provides AutomixIQ with the information from your service that it needs in order to play. The functions of this interface need to be implemented.</p> <ul> <li>If your custom backend puts fetching metadata and track data behind a login, AutomixIQ needs to know if the user in your aspplication is logged in or not. To provide this information, implement isLoggedIn. If your custom backend does not require a login, this function should return true.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun isLoggedIn() {\n        return this.loggedIn\n    }\n    // ...\n}\n</code></pre> <ul> <li>If your custom backend only allows playback on a device under certain conditions (for instance in only allows one device to play at any given time), AutomixIQ needs to know if a device is allowed to play. To get this information, implement asyncCheckDeviceStatus and run onComplete with the response. If so such requirement exists, this function should run onComplete(true).</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncCheckDeviceStatus(onComplete: ((Boolean) -&gt; Unit)?,\n                                        onError: ((AutomixSDKError) -&gt; Unit)?) -&gt; Unit) {\n        this.canDeviceContinuePlaying() { allowedToPlay -&gt;\n            onComplete(allowedToPlay)\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ requires devices to have a unique identifier. To provide it, implement getDeviceIdentifier.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun getDeviceIdentifier(): String? {\n        return this.deviceIdentifier\n    }\n    // ...\n}\n</code></pre> <ul> <li>This delegate provides hooks to inject cached track audio data and metadata, to shortcut for efficiency and prevent AutomixIQ from querying audio data and metadata to your custom backend if they are already available. This also enables offline playback when all required data is available on device. To provide this information, implement syncGetTrackMetadata and syncGetCachedTrack. If no cache exists and you do not support offline playback, these functions should return null.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun syncGetTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If I have this track cached, I should be able to tell its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null;\n        }\n        return this.metadataForTrack(trackId)\n    }\n\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If I have this track cached, I should be able to decrypt it and send the data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>At any time, when track metadata is available, AutomixIQ informs the delegate that track metadata is available. You can use this function to cache it for later use if you want.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun cacheMetadata(metadata: List&lt;AutomixSDKTrackModel&gt;) {\n        this.metadataForTrack[metadata.trackId] = metadata\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ will need you to download the trackmetadata as it needs it, by calling asyncGetTrackMetadata. Return the metadata by running onComplete, or an error by running onError.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncGetTrackMetadata(trackId: String,\n                                       onComplete: ((AutomixSDKTrackModel) -&gt; Unit)?,\n                                       onError: ((AutomixSDKError) -&gt; Unit)?) -&gt; Unit) {\n        this.getTrackMetadata(trackId) { error, trackMetadata -&gt;\n            val automixSDKTrackModel = translateMetadata(trackMetadata)\n            if (error != null) {\n                onError(error)\n                return@getTrackMetadata\n            }\n            onComplete(automixSDKTrackModel)\n            return@getTrackMetadata\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>When AutomixIQ needs to download a track, it will ask for the url for it by calling asyncGetStream. It supports sessionID if you want urls to expire and return 403s. Return the requested URL by running onComplete, or an error by running onError.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncGetStream(streamingDeviceId: String, sessionId: String, trackId: String, \n                                onComplete: ((String /* URL */, String? /* newSessionId */) -&gt; Unit)?,\n                                onError: ((AutomixSDKError) -&gt; Unit)?) {\n        this.getTrackURL(streamingDeviceId, sessionId, trackId) { error, url, newSessionId -&gt;\n            if (error != null) {\n                onError(error)\n                return@getTrackURL\n            }\n            onComplete(url, newSessionId, null)\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>When a track finishes downloading, AutomixIQ passes the audio data for you to cache if you need it:</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun trackCompletedDownload(trackId: String, data: ByteArray) {\n        this.cacheTrack(trackId, data)\n    }\n    // ...\n}\n</code></pre> <ul> <li>As a track is being downloaded, AutomixIQ will report download progress:</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun trackBufferingProgress(trackId: String, progress: Float) {\n        this.updateTrackDownloadProgress(trackId, progress)\n    }\n    // ...\n}\n</code></pre> <p>Do keep in mind this download is done lazily, as AutomixIQ requires data for analysis / playback. There is no guarantee a track will download in its entirety if the track is not played in its entirety.</p>"},{"location":"Configure-the-SDK/#automixsdkstatuslistener","title":"AutomixSDKStatusListener","text":"<p>The AutomixSDKStatusListener is responsible for updating your player's UI, please refer to Update UI</p>"},{"location":"Configure-the-SDK/#check-if-initialised","title":"Check if initialised","text":"<p>To check wether AutomixIQ is currently initialised, use </p> <pre><code>AutomixSDK.getInstance()?.initialised()\n</code></pre>"},{"location":"Control-playback/","title":"Control playback","text":"<p>In order to use playback controls, AutomixIQ needs to be Initialised and On. Please see Configure the SDK. Use the AutomixSDK singleton to control playback of the mix. Actions supported are:</p> <ul> <li>Clear playlist</li> <li>Load tracks</li> <li>Add track</li> <li>Add tracks</li> <li>Remove track</li> <li>Move track</li> <li>Play</li> <li>Pause</li> <li>Next</li> <li>Previous</li> <li>Back</li> <li>Seek</li> <li>Skip</li> <li>Reorder tracks</li> <li>Force pause after playback of current track</li> <li>Loop track</li> <li>Stop looping track</li> </ul> <p>Here are examples of how to use execute each actions:</p> <ul> <li> <p>Clear playlist: To empty the AutomixIQ playlist (which effectively also pauses music playback until new content is loaded), use <pre><code>    AutomixSDK.getInstance()?.resetMixToEmpty(onComplete = { status -&gt; \n        // Success\n    }, onError = automixSDKError, status -&gt; {\n        // Error\n    })\n</code></pre></p> </li> <li> <p>Load tracks: To reset the AutomixIQ playlist with a new set of tracks, use <pre><code>    val identifiers: List&lt;String&gt; = myPlaylist\n    val metadataList: List&lt;AutomixSDKTrackModel&gt; = mySetOfMetadata\n    val index = myPlaylistIndex\n    val startPositionSeconds = myTrackStartPosition\n    val contextType: String = myContextType\n    val contextId: String = myContextId\n    AutomixSDK.getInstance()?.loadTracks(\n        identifiers = identifiers,\n        metadata = metadataList,\n        playTrackIndex = index.coerceAtLeast(0),\n        seconds = startPositionSeconds,\n        autoplay = true,\n        contextType = contextType,\n        contextId = contextId,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Add track: To add a track to a playlist, use <pre><code>    val trackId: String = myTrackId\n    val trackMetadata: AutomixSDKTrackModel = myTrackMetadata\n    val index = myIndexToAddTrack\n    AutomixSDK.getInstance()?.addTrack(trackId, trackMetadata, index, \n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Add tracks: To add a list of tracks, use  AutomixSDK/addTracks(identifiers:metadata:index:onComplete:onEerror:) <pre><code>    val trackIds: List&lt;String&gt; = myTrackIds\n    val metadata: List&lt;AutomixSDKTrackModel&gt; = mySetOfMetadata\n    val index = myIndexToAddTracks\n    AutomixSDK.getInstance()?.addTracks(trackIds, metadata, index,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Remove track: To remove a track from the AutomixIQ playlist, use AutomixSDK/removeTrack(at:onComplete:onEerror:) <pre><code>    val index = myIndexToRemove\n    AutomixSDK.getInstance()?.removeTrack(index,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Move track: To move a track in an AutomixIQ playlist, use <pre><code>    val fromIndex = myIndexToMoveFrom\n    val toIndex = myIndexToMoveto\n    AutomixSDK.getInstance()?.moveTrack(fromIndex, toIndex,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Play: To start playback when AutomixIQ is paused, use <pre><code>    AutomixSDK.getInstance()?.play(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Pause: To pause playback when AutomixIQ is playing, use <pre><code>    AutomixSDK.getInstance()?.pause(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Next: To skip to the next track of the AUtomixIQ playlist, use <pre><code>    AutomixSDK.getInstance()?.next(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Previous: To skip to the previous track of the AutomixIQ playlist, use <pre><code>    AutomixSDK.getInstance()?.previous(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Back: To jump to the beginning of the track AUtomixIQ is currently playing, use <pre><code>    AutomixSDK.getInstance()?.back(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Seek: To jump to a position in the track AutomixIQ is playing, use <pre><code>    val seconds = myPositionToSeekTo\n    AutomixSDK.getInstance()?.seekTo(seconds,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Skip: To jump to a different track in the AutomixIQ playlist, use <pre><code>    val index = myIndexToSkipTo\n    AutomixSDK.getInstance()?.skipToTrackAtIndex(index,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Reorder tracks: To set the order of the tracks of AutomixIQ playlist to a different order, use <pre><code>    val newOrder: List&lt;String&gt; = myNewOrder\n    AutomixSDK.getInstance()?.reorderTracks(newOrder,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Force pause after playback of current track: If you want AutomixIQ to play the current track to the end and then pause, use <pre><code>    AutomixSDK.getInstance()?.playTrackUntilEndThenPause(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Loop track: To make AUtomixIQ play the current track to the end and then jump back to the beginning to continue playing it, use <pre><code>    AutomixSDK.getInstance()?.loopPlayingTrack(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Stop looping track: To stop looping a track when AutomixIQ is currently looping it, use <pre><code>    AutomixSDK.getInstance()?.stopLoopingPlayingTrack(\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> </ul>"},{"location":"Data-models/","title":"Data models","text":"<p>How is data passed to and from the AutomixIQ player</p> <ul> <li>AutomixSDKStatus</li> <li>AutomixSDKTrackModel</li> <li>AutomixSDKArtistModel</li> <li>AutomixSDKPluginMetadataDictionaryEntryModel</li> <li>TunedAuthenticationResponse</li> </ul> <p>Find the documentation of available APIs here: AutomixIQ</p>"},{"location":"Data-persistency/","title":"Data persistance","text":""},{"location":"Data-persistency/#music-metadata-database","title":"Music Metadata Database","text":"<p>In the Caches Directory, AutomixIQ keeps a light weight sql database to store the metadata of tracks that have been played for subsequent lookup. This file is called \"music.db\". It will be automatically created on launch.</p>"},{"location":"Data-persistency/#music-analysis-database","title":"Music Analysis Database","text":"<p>In the Caches Directory, AutomixIQ keeps a light weight sql database to store the analysis data of tracks that have been played for subsequent lookup. This analysis is required to produce beat-matched transitions. This file is called \"paralysis.db\". It will be automatically created on launch.</p>"},{"location":"Data-persistency/#transition-playback-log","title":"Transition Playback Log","text":"<p>AutomixIQ stores offline transition playback logs for subsequent reporting on a SqlLite database.</p>"},{"location":"Data-persistency/#clearing-the-cache","title":"Clearing the cache","text":"<p>To reset persistent analysis storage use</p> <pre><code>    AutomixSDK.getInstance()?.clearCache()\n</code></pre>"},{"location":"Errors/","title":"Errors","text":"<p>Find the enumeration describing errors this SDK can emmit here: AutomixSDKError Reference.</p> <p>Find the documentation of available APIs here: AutomixIQ API Reference</p>"},{"location":"Explicit-lyrics-filter/","title":"Explicit lyrics filter","text":"<p>AutomixIQ can be configured to avoid playback of tracks with explicit content. It can skip over or mix out of those tracks automatically. To do that you use <pre><code>    val filterExplicit: Boolean = myFilterExplicitSetting\n    AutomixSDK.getInstance()?.setFilterExplicit(filterExplicit,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> <p>If this filtering is enabled when no explict track is currently playing, then AutomixIQ will ensure the mix skips over tracks with explicit content, by creating a mix between the current track and the first non-explicit track. If all the remaining track is explicit, then AutomixIQ will act as if that track is the end of the playlist. If replay is on, then the first available non-explict track might be at the beginning of the set.</p> <p>If this filtering is enabled while AutomixIQ is playing a track with explicit lyrics, AutomixIQ will automatically skip to the first available non-explicit track. If no track that is not explit is available, then AutomixIQ will act as if that track is the end of the set. If replay is on, then the first available non-explict track might be at the beginning of the set. </p>"},{"location":"Install-the-SDK/","title":"Install the SDK","text":""},{"location":"Install-the-SDK/#requirements","title":"Requirements","text":"<p>This library requires minimum Android SDK Level 21, Android 5.0 Lollipop.</p>"},{"location":"Install-the-SDK/#importing-artifact","title":"Importing artifact","text":"<p>AutomixIQ can be brougth into your project via our private maven repository.</p> <p>Step 1: Add the Tuned Global's maven repository to the list of dependencies</p> <p>On your settings.gradle.kts, add the Tuned Global's maven repository:</p> <pre><code>dependencyResolutionManagement {\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     repositories {\n         // ...\n         maven {\n             url = uri(\"http://tgpm-maven-repo.s3-website-us-west-2.amazonaws.com/releases\")\n             isAllowInsecureProtocol = true\n         }\n         // ...\n     }\n}\n</code></pre> <p>Step 2: Add the dependency to your target</p> <p>In your build.gradle.kts file, add the AutomixIQ library:</p> <pre><code>  // ...\n  val automixIQVersion = myAutomixIQVersion // Desired version\n  implementation(\"com.tunedglobal:automix-sdk:$automixIQVersion\")\n  // ...\n</code></pre> <p>Step 3: Configure Proguard (Optional)</p> <p>If you have any issues finding classes in our SDK, try adding the following to your Proguard configuration.</p> <pre><code>-keep class com.tunedglobal.automix.logic.cpp.AMJNILib {\n    public static *;\n    public *;\n}\n</code></pre> <p>Step 4: You should now be able to use the AutomixIQ library</p> <pre><code>  // ...\n  import com.tunedglobal.automix.*\n  // ...\n</code></pre>"},{"location":"Player-settings/","title":"Player settings","text":"<p>AutomixIQ offers the following settings for further control:</p> <ul> <li>Set normalised tempo</li> <li>Set play speed</li> <li>Mute On/Off</li> <li>Replay On/Off</li> <li>Vinyl stop On/Off</li> <li>Volume</li> <li>Preferred transition duration</li> </ul> <p>Here are examples of how to use set each setting:</p> <ul> <li> <p>Set normalised tempo: to slow or speed up playback by -15% - 15%, use <pre><code>    val tempoNormalised: Float = myTempoNormaliased // Between 0 and 1!\n    AutomixSDK.getInstance()?.setAutomixTempoNormalised(tempoNormalised,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Set play speed: To speed up or slow down AutomixIQ playback by up to 2x, use <pre><code>    val playSpeed: Float = myTempoNormaliased // Between -2 and 2!\n    AutomixSDK.getInstance()?.setAutomixPlaySpeed(playSpeed,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Mute On/Off: To mute or unmute AUtomixIQ, use <pre><code>    val muted: Boolean = true // false?\n    AutomixSDK.getInstance()?.setMute(muted,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Replay On/Off: To make AUtomixIQ repeat the current playlist (or stop repeating the current playlist), use <pre><code>    val replay: Boolean = true // false?\n    AutomixSDK.getInstance()?.setReplay(replay,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Vinyl stop On/Off: To make AutomixIQ play a vinyl start-stop-like sound effect when playing or pausing (or remove this effect), use <pre><code>    val vinylPause: Boolean = true // false?\n    AutomixSDK.getInstance()?.setVinylStartStopEnabled(vinylPause,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Volume: To make AutomixIQ loader or quieter, use <pre><code>    val volumeNormalised: Float = myVolumeNormalised // Between 0 and 1!\n    AutomixSDK.getInstance()?.setAutomixVolumeNormalised(volumeNormalised,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> <li> <p>Preferred transition duration: To give AUtomixIQ a hint as to how long transitions should be, use <pre><code>    val transitionDurationHint: Float = myTransitionDuration // Set to 0 to allow AutomixIQ to decide optimally for itself!\n    AutomixSDK.getInstance()?.setPreferredTransitionDurationSeconds(transitionDurationHint,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> </li> </ul>"},{"location":"Turn-Automix-on-and-off/","title":"Turn AutomixIQ on and off","text":"<p>AutomixIQ's player can be started and stopped. In order to play music through AutomixIQ, you need to start it first, any other player that is playing music should be paused to prevent competing with audio control. When AutomixIQ is stopped, it will stop rendering audio and any other player can be resumed.</p>"},{"location":"Turn-Automix-on-and-off/#turn-automix-on","title":"Turn Automix on","text":"<p>You can start the player with no content, or start the player with loaded content. </p> <ul> <li>If you start the player with no content, content needs to be provided via the playback control methods later, see Control playback. To start the player with no content, use</li> </ul> <pre><code>    // ...\n    AutomixSDK.getInstance()?.automixOn(onComplete = { status -&gt; \n        this.started = true\n        // We are now waiting for content.\n        // ...    \n    }, onError = { error, status -&gt;\n        // Something went wrong, playback did not start\n    })\n\n    // ...\n</code></pre> <ul> <li>To start the player with preloaded content, use</li> </ul> <pre><code>    // ...\n\n    val electronicMusicPlaylist = listOf(\"116484855\",\"66906273\",\"120584575\",\"116887896\")\n    val cachedMetadata = listOf(trackMetadata1, trackMetadata2, trackMetadata3, trackMetadata4)\n    AutomixSDK.instance.automixOn(electronicMusicPlaylist,\n                                  cachedMetadata,\n                                  playTrackIndex=0, seconds=0, autoplay=true,\n                                  contextType=\"playlist\", contextId=\"some-playlist-id\",\n                                  onComplete = \n    { status -&gt; \n        this.started = true\n        // We are now playing content.\n        // ...\n    }, onError = { error, status -&gt;\n        // Something went wrong, playback did not start\n    }\n\n    // ...\n</code></pre>"},{"location":"Turn-Automix-on-and-off/#turn-automix-off","title":"Turn Automix off","text":"<p>To stop the player, use</p> <pre><code>    // ...\n\n    AutomixSDK.getInstance()?.automixOff(onComplete = \n    { status -&gt; \n        this.started = false\n        // We are no longer playing.\n        // ...    \n    }, onError = { error, status -&gt;\n        // Something went wrong, playback did not stop\n    }\n\n    // ...\n</code></pre> <p>This function reports the status of AutomixIQ at the time it was stopped, in case you want to have another player pick up playback where AutomixIQ left it. See Update UI.</p>"},{"location":"Turn-Automix-on-and-off/#check-if-on","title":"Check if on","text":"<p>To check wether AutomixIQ is currently on, use </p> <pre><code>AutomixSDK.getInstance()?.on()\n</code></pre>"},{"location":"Turn-Automix-on-and-off/#shut-down","title":"Shut down","text":"<p>To shut down AutomixIQ, use</p> <pre><code>    AutomixSDK.terminate()\n</code></pre> <p>After you have done this, if you want to use AutomixIQ again, you will need to initialise it again.</p>"},{"location":"Update-ui/","title":"Update UI","text":""},{"location":"Update-ui/#receive-status-updates","title":"Receive status updates","text":"<p>AutomixIQ reports its current state and any playback event via AutomixSDKStatusListener. This listener reports the status via its statusChanged method every time the status changed, and in the function it specifies the current status and the variables that were altered since the last time an update was issued. Use the status variables to update the content of your player UI. Here is an example implementation:</p> <pre><code>public class MyPlayer: AutomixSDKStatusListener {\n    // ...\n\n    var latestStatus: AutomixSDKStatus? = null\n    override fun statusChanged(variables:List&lt;AutomixSDKStatusVariable&gt;, status: AutomixSDKStatus) {\n        this.latestStatus = status\n        for (property in variables) {    \n            when (property) {\n                AutomixSDKStatusVariable.PLAYING -&gt; {\n                    // Change the look and feel of yor Play/Pause button here\n                    val playing = status.playing\n                    // ...\n                }\n                AutomixSDKStatusVariable.MIXING -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_INDEX -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_CURRENT_TIME -&gt; {\n                    // Change your track progress UI here \n                    val ellapsedTime = status.playingTrackCurrentTime\n                    val totalTime = status.playingTrackTotalTime\n                    // ...\n                }\n                AutomixSDKStatusVariable.PLAYING_TRACK_STREAMING_PROGRESS -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_TOTAL_TIME -&gt; {\n                    // Change your track progress UI here \n                    val ellapsedTime = status.playingTrackCurrentTime\n                    val totalTime = status.playingTrackTotalTime\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SKIP_TO_PREVIOUS -&gt; {\n                    // Change the look and feel of yor Previous button here\n                    val canSkipToPrevious = status.canSkipToPrevious\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SKIP_TO_NEXT -&gt; {\n                    // Change the look and feel of yor Next button here\n                    val canSkipToNext = status.canSkipToNext\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_PLAY_PAUSE -&gt; {\n                    // Change the look and feel of yor Play/Pause button here\n                    val canPlayPause = status.canPlayPause\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SEEK -&gt; {}\n                AutomixSDKStatusVariable.CAN_REORDER_TRACKS -&gt; {}\n                AutomixSDKStatusVariable.REPLAY_ON -&gt; {\n                    // Change the look and feel of yor Replay button here\n                    val replayOn = status.replayOn\n                    // ...\n                }\n                AutomixSDKStatusVariable.MUTED -&gt; {}\n                AutomixSDKStatusVariable.MASTER_TEMPO_NORMALISED -&gt; {}\n                AutomixSDKStatusVariable.NORMALISED_VOLUME -&gt; {}\n                AutomixSDKStatusVariable.REQUESTED_LOOP_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_INDEX_INTERNAL -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_CURRENT_TIME_INTERNAL -&gt; {}\n                AutomixSDKStatusVariable.CAN_BACK -&gt; {}\n                AutomixSDKStatusVariable.READY_TO_PLAY -&gt; {}\n                AutomixSDKStatusVariable.CAN_MIX_NOW -&gt; {}\n                AutomixSDKStatusVariable.PLAYLIST -&gt; {}\n                AutomixSDKStatusVariable.PLAY_SPEED -&gt; {}\n                AutomixSDKStatusVariable.PREFERRED_TRANSITION_DURATION_SECONDS -&gt; {}\n                AutomixSDKStatusVariable.REQUESTED_PAUSE_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.VINYL_START_STOP -&gt; {}\n                AutomixSDKStatusVariable.NEXT_TRANSITION_DURATION -&gt; {}\n                AutomixSDKStatusVariable.TRANSITION_START_TIME_SECONDS -&gt; {}\n                AutomixSDKStatusVariable.FAILED_TRACK_LOAD_IDENTIFIERS -&gt; {}\n                AutomixSDKStatusVariable.CAN_ON_OFF -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_ORIGINAL_SESSION_ID -&gt; {}\n                AutomixSDKStatusVariable.MIX_ID -&gt; {}\n            }\n        }\n    }\n\n\n    // ...\n}\n</code></pre>"},{"location":"Update-ui/#receive-playback-events","title":"Receive playback events","text":"<p>To listen to playback events, implement the playbackEvent method.</p> <pre><code>public class MyPlayer: AutomixSDKStatusListener {\n    // ...\n\n    override fun playbackEvent(type: AutomixSDKPlaybackEventType, identifier: String?, originalSessionId: String?, status: AutomixSDKStatus?) {\n        when (type) {\n            AutomixSDKPlaybackEventType.trackPlayStart -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayPlayed5Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayHeartbeat30Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlaySkipped -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayFinished -&gt; {}\n            AutomixSDKPlaybackEventType.mixPlaybackEnded -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayStartMixingIntoNext -&gt; {}\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>The type of playback event is modelled by the enum AutomixSDKPlaybackEventType.</p>"},{"location":"Update-ui/#automix-status","title":"Automix Status","text":"<p>The status of AutomixIQ is modelled by AutomixSDKStatus. Find the documentation of available APIs here: AutomixIQ</p>"}]}