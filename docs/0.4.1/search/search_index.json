{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AutomixIQ","text":"<p>Provide seamless transitions between tracks and beat-matched seek experience within your music player application on Android.</p>"},{"location":"#overview","title":"Overview","text":"<p>AutomixIQ is a framework that offers a player capable of playing music continuously in your playlist. By analyzing the tracks in your playlist, it provides optimal machine-learned transitions between the tracks, as well as smooth transitions when you seek within a track. This player can function as an automatic DJ for your music, making jumps in play position within tracks feel as if no seek ever occurred.</p> <p> </p>"},{"location":"API-reference/","title":"API Reference","text":"<p>Find the documentation of available APIs here: AutomixIQ API Reference</p>"},{"location":"Change-log/","title":"Change Log","text":"<p>This is a dev build - No change log available.</p>"},{"location":"Configure-the-SDK-custom/","title":"Configure the SDK with custom Backend","text":""},{"location":"Configure-the-SDK-custom/#initialise-with-custom-backend","title":"Initialise with Custom backend","text":"<p>In order to initialise AutomixIQ when you take the responsibility of providing audio data and metadata you need the application context, an AutomixSDKStreamingListener, plus a store ID, applicationId and a country code.</p> <pre><code>override fun onStart(arguments: Bundle?) {\n    // ...\n\n    val applicationContext: ApplicationContext = myApplicationContext\n    val automixSDKStreamingListener: AutomixSDKStreamingListener = myAutomixSDKStreamingListener\n\n    val countryCode: String = myCountryCode // \"US\" ? \"AU\"?\n    val storeId: String = myTunedStoreId\n    val applicationId: String = myApplicationId\n    val config = AutomixSDKConfig.Builder().country(countryCode).storeId(storeId).applicationId(applicationId).logLevel(4).build()\n\n    AutomixSDK.initialise(applicationContext,\n                          automixSDKStreamingListener,\n                          config,\n                          onComplete = \n    { _ -&gt; \n        // The Automix SDK public functions can be used from this point onwards :)\n\n        // We can add a status listener to get UI updates and play events\n        val automixSDKStatusListener: AutomixSDKStatusListener = myAutomixSDKStatusListener\n        AutomixSDK.getInstance()?.addStatusListener(automixSDKStatusListener)\n\n        // ...\n    }, onError = { error, _ -&gt;\n        // This means you are forbidden to use the Automix SDK or you have no internet connection.\n    })\n\n    // ...\n}\n</code></pre>"},{"location":"Configure-the-SDK-custom/#implementing-an-instance-of-automixsdkstreaminglistener","title":"Implementing an instance of AutomixSDKStreamingListener","text":"<p>AutomixSDKStreamingListener provides AutomixIQ with the information from your service that it needs in order to play. The functions of this interface need to be implemented.</p> <ul> <li>If your custom backend puts fetching metadata and track data behind a login, AutomixIQ needs to know if the user in your aspplication is logged in or not. To provide this information, implement isLoggedIn. If your custom backend does not require a login, this function should return true.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun isLoggedIn() {\n        return this.loggedIn\n    }\n    // ...\n}\n</code></pre> <ul> <li>If your custom backend only allows playback on a device under certain conditions (for instance in only allows one device to play at any given time), AutomixIQ needs to know if a device is allowed to play. To get this information, implement asyncCheckDeviceStatus and run onComplete with the response. If so such requirement exists, this function should run onComplete(true).</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncCheckDeviceStatus(onComplete: ((Boolean) -&gt; Unit)?,\n                                        onError: ((AutomixSDKError) -&gt; Unit)?) -&gt; Unit) {\n        this.canDeviceContinuePlaying() { allowedToPlay -&gt;\n            onComplete(allowedToPlay)\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ requires devices to have a unique identifier. To provide it, implement getDeviceIdentifier.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun getDeviceIdentifier(): String? {\n        return this.deviceIdentifier\n    }\n    // ...\n}\n</code></pre> <ul> <li>This delegate provides hooks to inject cached track audio data and metadata, to shortcut for efficiency and prevent AutomixIQ from querying audio data and metadata to your custom backend if they are already available. This also enables offline playback when all required data is available on device. To provide this information, implement syncGetTrackMetadata and syncGetCachedTrack. If no cache exists and you do not support offline playback, these functions should return null.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun syncGetTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If I have this track cached, I should be able to tell its metadata\n        if (!this.isTrackCached(trackId)) {\n            return null;\n        }\n        return this.metadataForTrack(trackId)\n    }\n\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If I have this track cached, I should be able to decrypt it and send the data\n        if (!this.isTrackCached(trackId)) {\n            return null\n        }\n        return this.unencryptedDataForTrack(trackId)\n    }\n    // ...\n}\n</code></pre> <ul> <li>At any time, when track metadata is available, AutomixIQ informs the delegate that track metadata is available. You can use this function to cache it for later use if you want.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun cacheMetadata(metadata: List&lt;AutomixSDKTrackModel&gt;) {\n        this.metadataForTrack[metadata.trackId] = metadata\n    }\n    // ...\n}\n</code></pre> <ul> <li>AutomixIQ will need you to download the trackmetadata as it needs it, by calling asyncGetTrackMetadata. Return the metadata by running onComplete, or an error by running onError.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncGetTrackMetadata(trackId: String,\n                                       onComplete: ((AutomixSDKTrackModel) -&gt; Unit)?,\n                                       onError: ((AutomixSDKError) -&gt; Unit)?) -&gt; Unit) {\n        this.getTrackMetadata(trackId) { error, trackMetadata -&gt;\n            val automixSDKTrackModel = translateMetadata(trackMetadata)\n            if (error != null) {\n                onError(error)\n                return@getTrackMetadata\n            }\n            onComplete(automixSDKTrackModel)\n            return@getTrackMetadata\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>When AutomixIQ needs to download a track, it will ask for the url for it by calling asyncGetStream. It supports sessionID if you want urls to expire and return 403s. Return the requested URL by running onComplete, or an error by running onError.</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun asyncGetStream(streamingDeviceId: String, sessionId: String, trackId: String, \n                                onComplete: ((String /* URL */, String? /* newSessionId */) -&gt; Unit)?,\n                                onError: ((AutomixSDKError) -&gt; Unit)?) {\n        this.getTrackURL(streamingDeviceId, sessionId, trackId) { error, url, newSessionId -&gt;\n            if (error != null) {\n                onError(error)\n                return@getTrackURL\n            }\n            onComplete(url, newSessionId, null)\n        }\n    }\n    // ...\n}\n</code></pre> <ul> <li>When a track finishes downloading, AutomixIQ passes the audio data for you to cache if you need it:</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun trackCompletedDownload(trackId: String, data: ByteArray) {\n        this.cacheTrack(trackId, data)\n    }\n    // ...\n}\n</code></pre> <ul> <li>As a track is being downloaded, AutomixIQ will report download progress:</li> </ul> <pre><code>public class MyAutomixSDKStreamingListener: AutomixSDKStreamingListener {\n    // ...\n    override fun trackBufferingProgress(trackId: String, progress: Float) {\n        this.updateTrackDownloadProgress(trackId, progress)\n    }\n    // ...\n}\n</code></pre> <p>Do keep in mind this download is done lazily, as AutomixIQ requires data for analysis / playback. There is no guarantee a track will download in its entirety if the track is not played in its entirety.</p>"},{"location":"Configure-the-SDK-custom/#automixsdkstatuslistener","title":"AutomixSDKStatusListener","text":"<p>The AutomixSDKStatusListener is responsible for updating your player's UI, please refer to Update UI</p>"},{"location":"Configure-the-SDK-custom/#check-if-initialised","title":"Check if initialised","text":"<p>To check wether AutomixIQ is currently initialised, use </p> <pre><code>AutomixSDK.getInstance()?.initialised()\n</code></pre>"},{"location":"Configure-the-SDK-tuned/","title":"Configure the SDK with Tuned Global Backend","text":"<p>To initialise AutomixIQ with Tuned Global's APIs and services, you need </p> <ul> <li>A store ID and an application ID provided by the Tuned Global team</li> <li>You need to implement the <code>TunedRestHook</code> interface</li> </ul>"},{"location":"Configure-the-SDK-tuned/#implement-your-tunedresthook","title":"Implement your TunedRestHook","text":"<p><code>TunedRestHook</code> is an interface that facilitates communication between the Tuned Global Backend and the AutomixIQ SDK regarding the user's access token and device information. Extend the <code>TunedRestHook</code> class and implement the required functions as shown below:</p> <ul> <li>asyncGetAuthenticatedDevice</li> <li>providesAuthenticatedDevice</li> <li>uniqueDeviceIdentifier</li> <li>tunedRestTokenExpired</li> </ul> <p>You can find a detailed explanation in API Reference</p> <pre><code>public class MyTunedRestHook: TunedRestHook {\n\n    // Return the deviceId from Tuned service through onComplete\n    fun asyncGetAuthenticatedDevice(deviceIdentifierForVendor: String,\n                                    onComplete: ((String) -&gt; Unit)?,\n                                    onError: ((AutomixSDKError) -&gt; Unit)?) {\n        val myTunedDeviceId: String = tunedDeviceId\n        onComplete?.invoke(myTunedDeviceId.toString())\n        return\n    }\n\n    // Tell AutomixIQ whether it needs to use the device provided (true) from uniqueDeviceIdentifier()\n    // or register a device on its own (false).\n    fun providesAuthenticatedDevice(): Boolean = true // or false\n\n    // Return a UUID that is used to identify a device. This is the `deviceIdentifierForVendor`\n    fun uniqueDeviceIdentifier(): String {\n        val uuid: String = myUniqueDeviceIdentifier\n        return uuid\n    }\n\n    // Use the info provided from the parameters to refresh the Tuned user token \n    // and return TunedAuthenticationResponse and userID through onComplete\n    override fun tunedRestTokenExpired(deviceIdentifierForVendor: String,\n                                        countryCode: String,\n                                        tunedUserId: String?,\n                                        oldAccessToken: String?,\n                                        refreshToken: String?,\n                                        tokenType: String?,\n                                        onComplete: ((TunedAuthenticationResponse?, String) -&gt; Unit)?,\n                                        onError: ((AutomixSDKError) -&gt; Unit)?) {\n        // your implementation of refreshing Tuned user Token                                    \n        refreshToken(refreshToken, tokenType, deviceIdentifierForVendor) { authToken -&gt;\n            val userId = tunedUserId\n            val tunedAuthenticationResponse = TunedAuthenticationResponse(\n                it.accessToken,\n                \"bearer\",\n                it.expiration.toInt(),\n                it.refreshToken,\n                userId\n            )\n            onComplete?.invoke(tunedAuthenticationResponse, userId)\n        }\n    }\n}\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#initialise-automixsdk-instance","title":"Initialise AutomixSDK instance","text":"<p>Create an <code>AutomixSDKConfig</code> first. You can get the store ID, application ID from the Tuned Global team.</p> <pre><code>val automixConfig = \n    AutomixSDKConfig.Builder()\n        .country(myCountryISO2Code) // e.g. \"US\", \"AU\"\n        .storeId(myTunedStoreId )\n        .applicationId(myTunedApplicationId)\n        .logLevel(AutomixSDKLogLevel.DEBUG)\n        .build()\n</code></pre> <p>Initialise the AutomixSDK instance with the <code>TunedRestHook</code> and <code>AutomixSDKConfig</code> created in previous steps. We recommend initialising the SDK once your music background service is up and running.</p> <p>Note</p> <p>AutomixIQ requires an active internet connection for its initial verification. After this initial setup, you can initialise it offline. However, note that there is a grace period of 7 days, after which an internet connection will be required again for re-verification.</p> <pre><code>AutomixSDK.initialise(applicationContext,\n                        myTunedRestHook,\n                        automixConfig,\n                        onComplete = { automixStatus -&gt; \n\n        // The AutomixIQ public functions can be used from this point onwards :)\n\n        // We can set a cached music provider if we want to support offline playback\n        val cachedMusicProvider: AutomixSDKCachedMusicProvider = myCachedMusicProvider\n        AutomixSDK.getInstance()?.setCachedMusicProvider(cachedMusicProvider)\n\n        // We can add a status listener to get UI updates and play events, you can add as many AutomixSDKStatusListener as you like\n        val automixSDKStatusListener: AutomixSDKStatusListener = myAutomixSDKStatusListener\n        AutomixSDK.getInstance()?.addStatusListener(automixSDKStatusListener)\n\n        // ...\n    }, onError = { automixSDKError, automixSDKStatus -&gt; \n        // This means you do not have permission to use the AutomixIQ or there is no internet connection when required.\n        return\n    })\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#implement-automixsdkcachedmusicprovider-optional","title":"Implement AutomixSDKCachedMusicProvider (Optional)","text":"<p>AutomixIQ supports offline playback using local music data. You can implement the <code>AutomixSDKCachedMusicProvider</code> to inject cached track metadata and raw audio data, extract raw audio data downloaded by the SDK, and monitor the download progress. This approach enhances efficiency and prevents AutomixIQ from streaming audio data and downloading metadata from Tuned Global's APIs if they are already available. It also enables offline playback when all the required data is available locally. </p> <p>Implement the <code>AutomixSDKCachedMusicProvider</code> and add it to the SDK after initialise. </p> <p>You can find a detailed explanation in API Reference</p> SetCachedMusicProvider<pre><code>AutomixSDK.getInstance()?.setCachedMusicProvider(MyCachedMusicProvider())\n</code></pre> MyCachedMusicProvider<pre><code>public class MyCachedMusicProvider: AutomixSDKCachedMusicProvider {\n\n    // Provide the track metadata. For offline playback, this is required.\n    override fun syncGetTrackMetadata(trackId: String?): AutomixSDKTrackModel? {\n        // If the track is not cached, return null and AutomixIQ will try to fetch it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n        return metadataForTrack(trackId)\n    }\n\n    // Provide the raw audio byte data of the audio file. For offline playback, this is required.\n    override fun syncGetCachedTrack(trackId: String): ByteArray? {\n        // If the track is not cached, return null and AutomixIQ will try to stream it.\n        if (!isTrackCached(trackId)) {\n            return null\n        }\n\n        return rawAudioDataForTrack(trackId)\n    }\n\n    // AutomixIQ will stream and download the tracks it needs to play when they are not provided from `syncGetCachedTrack`. \n    // It will do so lazily (as playback or analysis requires). \n    // When a track finished downloading, AutomixIQ will pass the raw audio byte data here for caching.\n    override fun trackFinishedDownloading(trackId: String, data: ByteArray) {\n        cacheTrack(trackId, data)\n    }\n\n    // Monitor the download progress\n    override fun trackBufferingProgress(trackId: String, progress: Float) {\n        updateTrackBufferingProgress(trackId, progress)\n    }\n}\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#check-initialised-state","title":"Check initialised state","text":"<p>To check whether AutomixIQ is initialised </p> <pre><code>AutomixSDK.getInstance()?.initialised()\n</code></pre>"},{"location":"Configure-the-SDK-tuned/#shut-down","title":"Shut down","text":"<p>To shut down AutomixIQ</p> <pre><code>AutomixSDK.terminate()\n</code></pre> <p>After you have terminated the SDK, you will need to reinitialise if you want to use AutomixIQ again.</p>"},{"location":"Control-playback/","title":"Control playback","text":"<p>AutomixIQ's player needs to be turned on before using any of the following playback controls API, see Turn AutomixIQ on and off. </p> <p>Use the <code>AutomixSDK</code> instance to control playback.</p> <pre><code>AutomixSDK.getInstance()\n</code></pre> <p>Playback control APIs include:</p> <ul> <li>Load tracks</li> <li>Add track</li> <li>Add tracks</li> <li>Remove track</li> <li>Move track</li> <li>Reorder tracks (Shuffle)</li> <li>Clear playlist</li> <li>Play</li> <li>Pause</li> <li>Next</li> <li>Previous</li> <li>Skip to a track</li> <li>Back</li> <li>Seek</li> <li>Loop track</li> <li>Stop looping track</li> <li>Force pause after playback of current track</li> </ul>"},{"location":"Control-playback/#load-tracks","title":"Load tracks","text":"<p>Loads a new set of tracks to the AutomixIQ player, it will override the currently loaded playlist.</p> <pre><code>val identifiers: List&lt;String&gt; = myPlaylist \nval metadataList: List&lt;AutomixSDKTrackModel&gt; = mySetOfMetadata\nval index = myPlaylistIndex\nval startPositionSeconds = myTrackStartPosition\nval contextType: String = myContextType\nval contextId: String = myContextId\n\nAutomixSDK.getInstance()?.loadTracks(\n    identifiers = identifiers,\n    metadata = metadataList,\n    playTrackIndex = index.coerceAtLeast(0),\n    seconds = startPositionSeconds,\n    autoplay = true,\n    contextType = contextType,      // for reporting purpose\n    contextId = contextId,          // for reporting purpose\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#add-track","title":"Add track","text":"<p>Add a track to the current playlist at a given index</p> <pre><code>val trackId: String = myTrackId\nval trackMetadata: AutomixSDKTrackModel = myTrackMetadata\nval index = myIndexToAddTrack\n\nAutomixSDK.getInstance()?.addTrack(trackId, trackMetadata, index, \n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#add-tracks","title":"Add tracks","text":"<p>Add a list of tracks to the current playlist at a given index</p> <pre><code>val trackIds: List&lt;String&gt; = myTrackIds\nval metadata: List&lt;AutomixSDKTrackModel&gt; = mySetOfMetadata\nval index = myIndexToAddTracks\n\nAutomixSDK.getInstance()?.addTracks(trackIds, metadata, index,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#remove-track","title":"Remove track","text":"<p>Remove a single track at a given index from the current playlist</p> <pre><code>val index = myIndexToRemove\n\nAutomixSDK.getInstance()?.removeTrack(index,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#move-track","title":"Move track","text":"<p>Move a single track within the current playlist</p> <pre><code>val fromIndex = myIndexToMoveFrom\nval toIndex = myIndexToMoveto\n\nAutomixSDK.getInstance()?.moveTrack(fromIndex, toIndex,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#reorder-tracks-shuffle","title":"Reorder tracks (Shuffle)","text":"<p>Reorder the sequence of the tracks in the current playlist. Use this API to achieve shuffle playback. </p> <pre><code>val newOrder: List&lt;String&gt; = identifiersInNewOrder\n\nAutomixSDK.getInstance()?.reorderTracks(newOrder,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#clear-playlist","title":"Clear playlist","text":"<p>Clears the playlist loaded in AutomixIQ's player, which also stops music playback.</p> <pre><code>AutomixSDK.getInstance()?.resetPlaylistToEmpty(\n    onComplete = { automixSDKStatus -&gt; \n        // Success\n    }, onError = automixSDKError, automixSDKStatus -&gt; {\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#play","title":"Play","text":"<p>Start or resume playback when the player is paused</p> <pre><code>AutomixSDK.getInstance()?.play(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#pause","title":"Pause","text":"<p>Pause playback when the player is playing</p> <pre><code>AutomixSDK.getInstance()?.pause(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#next","title":"Next","text":"<p>Skip to the next track in the playlist, returns error if <code>CAN_SKIP_TO_NEXT</code> is false</p> <pre><code>AutomixSDK.getInstance()?.next(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#previous","title":"Previous","text":"<p>Skip to the previous track in the playlist, returns error if <code>CAN_SKIP_TO_PREVIOUS</code> is false</p> <pre><code>AutomixSDK.getInstance()?.previous(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#skip-to-a-track","title":"Skip to a track","text":"<p>Skip to a given track in the playlist based on index.</p> <pre><code>val index = myIndexToSkipTo\n\nAutomixSDK.getInstance()?.skipToTrackAtIndex(index,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#back","title":"Back","text":"<p>Seek to the start of the current track and start playback</p> <pre><code>AutomixSDK.getInstance()?.back(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#seek","title":"Seek","text":"<p>Jump to a position in the current track, can be used when playing or paused</p> <pre><code>val seconds = myPositionToSeekTo\n\nAutomixSDK.getInstance()?.seekTo(seconds,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#loop-track","title":"Loop track","text":"<p>Loop the current playing track when it finishes. Use this API to achieve single loop playback. For playlist loop, see Replay</p> <pre><code>AutomixSDK.getInstance()?.loopPlayingTrack(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#stop-looping-track","title":"Stop looping track","text":"<p>Stop looping the current playing track. </p> <pre><code>AutomixSDK.getInstance()?.stopLoopingPlayingTrack(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Control-playback/#force-pause-after-playback-of-current-track","title":"Force pause after playback of current track","text":"<p>Force the player to pause after the current playing track finishes. This is useful when you would like to play an Ad or do something else in between tracks.</p> <pre><code>AutomixSDK.getInstance()?.playTrackUntilEndThenPause(\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Data-model/","title":"Data model","text":"<p>List of enums and data models used by AutomixIQ to communicate with the host app.</p>"},{"location":"Data-model/#enums","title":"Enums","text":"<ul> <li>AutomixSDKLogLevel</li> <li>AutomixSDKPlaybackEventType</li> <li>AutomixSDKError</li> <li>AutomixSDKStatusVariable</li> </ul>"},{"location":"Data-model/#data-models","title":"Data Models","text":"<ul> <li>TunedAuthenticationResponse</li> <li>AutomixSDKConfig</li> <li>AutomixSDKTrackModel</li> <li>AutomixSDKArtistModel</li> <li>AutomixSDKPluginMetadataDictionaryEntryModel</li> <li>AutomixSDKStatus</li> </ul>"},{"location":"Data-persistency/","title":"Data persistance","text":""},{"location":"Data-persistency/#music-metadata-database","title":"Music Metadata Database","text":"<p>In the Caches Directory, AutomixIQ keeps a light weight sql database to store the metadata of tracks that have been played for subsequent lookup. This file is called \"music.db\". It will be automatically created on launch.</p>"},{"location":"Data-persistency/#music-analysis-database","title":"Music Analysis Database","text":"<p>In the Caches Directory, AutomixIQ keeps a light weight sql database to store the analysis data of tracks that have been played for subsequent lookup. This analysis is required to produce beat-matched transitions. This file is called \"paralysis.db\". It will be automatically created on launch.</p>"},{"location":"Data-persistency/#transition-playback-log","title":"Transition Playback Log","text":"<p>AutomixIQ stores offline transition playback logs for subsequent reporting on a SqlLite database.</p>"},{"location":"Data-persistency/#clearing-the-cache","title":"Clearing the cache","text":"<p>To reset persistent analysis storage use</p> <pre><code>    AutomixSDK.getInstance()?.clearCache()\n</code></pre>"},{"location":"Explicit-lyrics-filter/","title":"Explicit lyrics filter","text":"<p>AutomixIQ can be configured to avoid playback of tracks with explicit content. It can skip over or mix out of those tracks automatically. To do that you use <pre><code>    val filterExplicit: Boolean = myFilterExplicitSetting\n    AutomixSDK.getInstance()?.setFilterExplicit(filterExplicit,\n        onComplete = { status -&gt;\n            // Success\n        },\n        onError = { automixSDKError, status -&gt;\n            // Error\n        }\n    )\n</code></pre></p> <p>If this filtering is enabled when no explict track is currently playing, then AutomixIQ will ensure the mix skips over tracks with explicit content, by creating a mix between the current track and the first non-explicit track. If all the remaining track is explicit, then AutomixIQ will act as if that track is the end of the playlist. If replay is on, then the first available non-explict track might be at the beginning of the set.</p> <p>If this filtering is enabled while AutomixIQ is playing a track with explicit lyrics, AutomixIQ will automatically skip to the first available non-explicit track. If no track that is not explit is available, then AutomixIQ will act as if that track is the end of the set. If replay is on, then the first available non-explict track might be at the beginning of the set. </p>"},{"location":"Handle-error/","title":"Errors","text":"<p>Find the enumeration describing errors this SDK can emmit here: AutomixSDKError Reference.</p> <p>Find the documentation of available APIs here: AutomixIQ API Reference</p>"},{"location":"Install-the-SDK/","title":"Install the SDK","text":""},{"location":"Install-the-SDK/#requirements","title":"Requirements","text":"<p>This library requires a minimum Android SDK Level 21, Android 5.0 Lollipop.</p>"},{"location":"Install-the-SDK/#importing-artifact","title":"Importing artifact","text":"<p>AutomixIQ can be brougth into your project via our private maven repository.</p> <p>Step 1: Include Tuned Global's maven repository</p> settings.gradle.kts<pre><code>dependencyResolutionManagement {\n     repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)\n     repositories {\n         // ...\n         maven(url = \"https://tunedglobal.pkgs.visualstudio.com/TunedAutomix.Android.Releases/_packaging/AutoMixAndroidFeed/maven/v1\")\n         // ...\n     }\n}\n</code></pre> <p>Step 2: Add the dependency to your target</p> build.gradle.kts<pre><code>val automixIQVersion = myAutomixIQVersion // Latest version: \"0.4.0\"\n\ndependencies {\n    // ...\n    implementation(\"com.tunedglobal:automixiq:$automixIQVersion\")\n    // ...\n}\n</code></pre> <p>Step 3: You should now be able to use the AutomixIQ library</p> <pre><code>  // ...\n  import com.tunedglobal.automix.*\n  // ...\n</code></pre>"},{"location":"Install-the-SDK/#configure-proguard-optional","title":"Configure Proguard (Optional)","text":"<p>If you have any issues finding classes in our SDK, try adding the following to your Proguard configuration.</p> <pre><code>-keep class com.tunedglobal.automix.logic.cpp.AMJNILib {\n    public static *;\n    public *;\n}\n</code></pre>"},{"location":"Player-setting/","title":"Player setting","text":"<p>AutomixIQ's player provides a list of settings for enhanced control over playback.</p> <p>Use the <code>AutomixSDK</code> instance to modify player settings.</p> <pre><code>AutomixSDK.getInstance()\n</code></pre> <p>Player setting APIs include:</p> <ul> <li>Playback speed</li> <li>Mute</li> <li>Replay</li> <li>Vinyl start/stop SFX</li> <li>Volume</li> <li>Transition duration</li> </ul>"},{"location":"Player-setting/#playback-speed","title":"Playback speed","text":"<p>Similar to tempo, adjust the playback speed with a wider range. The accepted range is 0.5x to 2x of the original playback speed.</p> <ul> <li>Set the value to 0.5 will play the track at 0.5x speed</li> <li>Set the value to 1 will play the track at 1x speed</li> <li>Set the value to 2 will play the track at 2x speed</li> <li>You can set the value anywhere between 0.5 and 2</li> </ul> <pre><code>val playbackSpeed: Float = myPlaybackSpeed      // range from 0.5 to 2\n\nAutomixSDK.getInstance()?.setAutomixPlaySpeed(playbackSpeed,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#volume","title":"Volume","text":"<p>Adjust the volume of the player. This does not change the Android system volume.</p> <pre><code>val volumeNormalised: Float = myVolumeNormalised    // range from 0 to 1\n\nAutomixSDK.getInstance()?.setAutomixVolumeNormalised(volumeNormalised,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#mute","title":"Mute","text":"<p>Mute/unmute the player</p> <pre><code>val muted: Boolean = true   // or false\n\nAutomixSDK.getInstance()?.setMute(muted,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#replay","title":"Replay","text":"<p>Loop the current playlist when it finishes. Use this API to achieve playlist loop playback, For single loop, see Loop track</p> <pre><code>val replay: Boolean = true      // or false\n\nAutomixSDK.getInstance()?.setReplay(replay,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#vinyl-startstop-sfx","title":"Vinyl start/stop SFX","text":"<p>The player plays a vinyl start/stop sound effect when resuming or pausing, use this API to enable/disable this SFX. </p> <p>Note</p> <p>This SFX is turned on by default</p> <pre><code>val enableVinylSFX: Boolean = true      // or false\n\nAutomixSDK.getInstance()?.setVinylStartStopEnabled(enableVinylSFX,\n    onComplete = { automixSDKStatus -&gt;\n        // Success\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Player-setting/#transition-duration","title":"Transition duration","text":"<p>Set a preferred transition duration in seconds for the natural transition between tracks. The SDK will try to generate a smooth transition based on the value set.</p> <pre><code>// range from 0 to 30. If set as 0, the SDK will decide the best transtion duration\nval transitionDurationHint: Float = myTransitionDuration        \n\nAutomixSDK.getInstance()?.setPreferredTransitionDurationSeconds(transitionDurationHint,\n    onComplete = { status -&gt;\n        // Success\n    },\n    onError = { automixSDKError, status -&gt;\n        // Error\n    }\n)\n</code></pre>"},{"location":"Turn-Automix-on-and-off/","title":"Turn AutomixIQ on and off","text":"<p>AutomixIQ's player can be turned on or off after initialisation. You need to turn on the player before playing any music.</p> <p>Note</p> <p>If there is another player currently playing music, we suggest pausing the playback once AutomixIQ's player is turned on to prevent competing for audio control. When AutomixIQ's player is turned off, any other player can be resumed.</p>"},{"location":"Turn-Automix-on-and-off/#turn-automixiq-on","title":"Turn AutomixIQ on","text":"<p>You can turn on the player without any tracks, or turn on the player with a list of tracks and its metadata. </p> Turn on without tracks<pre><code>AutomixSDK.getInstance()?.automixOn(\n    onComplete = { automixSDKStatus -&gt; \n        // Player is turn on and is waiting for tracks to be loaded.\n    }, onError = { automixSDKError, automixSDKStatus -&gt;\n        // Something went wrong, playback did not start\n    }\n)\n</code></pre> <p>Note</p> <p>If you start the player without tracks, tracks will need to be provided via the playback control methods later, see Load tracks in Control playback.</p> Turn on with tracks<pre><code>// list of track ids\nval electronicMusicPlaylist = listOf(\"116484855\",\"66906273\",\"120584575\",\"116887896\")\n\n// list of metadata for tracks\nval cachedMetadata = listOf(trackMetadata1, trackMetadata2, trackMetadata3, trackMetadata4) \n\nAutomixSDK.getInstance()?.automixOn(\n    identifiers = electronicMusicPlaylist,\n    metadata = cachedMetadata,      // nullable, if null and the SDK will call `syncGetTrackMetadata` in `AutomixSDKCachedMusicProvider` to get metadata\n    playTrackIndex = 0,             // start playback index in playlist\n    seconds = 0,                    // start playback second in track\n    autoplay = true,                // start playback immediately or not\n    contextType = \"playlist\",       // for reporting purpose\n    contextId = \"playlist-id\",      // for reporting purpose\n    onComplete = { automixSDKStatus -&gt; \n        // Player is turn on and will start playback if autoplay is true\n    }, onError = { automixSDKError, automixSDKStatus -&gt;\n        // Something went wrong, playback did not start\n    }\n)\n</code></pre>"},{"location":"Turn-Automix-on-and-off/#turn-automixiq-off","title":"Turn AutomixIQ off","text":"<p>Turning off AutomixIQ's player will stop playback</p> <pre><code>AutomixSDK.getInstance()?.automixOff(\n    onComplete = { automixSDKStatus -&gt; \n        // Playback should be stopped by now, resume other players if needed.\n        // `automixSDKStatus` contains the last status of the player, can be used to provide information to other players to resume playback.\n    },\n    onError = { automixSDKError, automixSDKStatus -&gt;\n        // Something went wrong, playback did not stop\n    }\n)\n</code></pre> <p>For more information about <code>AutomixSDKStatus</code>, see Update UI.</p>"},{"location":"Turn-Automix-on-and-off/#check-onoff-state","title":"Check on/off state","text":"<p>To check whether AutomixIQ's player is turned on</p> <pre><code>AutomixSDK.getInstance()?.on()\n</code></pre>"},{"location":"Update-ui/","title":"Update UI","text":""},{"location":"Update-ui/#receive-status-updates","title":"Receive status updates","text":"<p>AutomixIQ reports its current state and any playback event via AutomixSDKStatusListener. This listener reports the status via its statusChanged method every time the status changed, and in the function it specifies the current status and the variables that were altered since the last time an update was issued. Use the status variables to update the content of your player UI. Here is an example implementation:</p> <pre><code>public class MyPlayer: AutomixSDKStatusListener {\n    // ...\n\n    var latestStatus: AutomixSDKStatus? = null\n    override fun statusChanged(variables:List&lt;AutomixSDKStatusVariable&gt;, status: AutomixSDKStatus) {\n        this.latestStatus = status\n        for (property in variables) {    \n            when (property) {\n                AutomixSDKStatusVariable.PLAYING -&gt; {\n                    // Change the look and feel of yor Play/Pause button here\n                    val playing = status.playing\n                    // ...\n                }\n                AutomixSDKStatusVariable.MIXING -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_INDEX -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_CURRENT_TIME -&gt; {\n                    // Change your track progress UI here \n                    val ellapsedTime = status.playingTrackCurrentTime\n                    val totalTime = status.playingTrackTotalTime\n                    // ...\n                }\n                AutomixSDKStatusVariable.PLAYING_TRACK_STREAMING_PROGRESS -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_TOTAL_TIME -&gt; {\n                    // Change your track progress UI here \n                    val ellapsedTime = status.playingTrackCurrentTime\n                    val totalTime = status.playingTrackTotalTime\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SKIP_TO_PREVIOUS -&gt; {\n                    // Change the look and feel of yor Previous button here\n                    val canSkipToPrevious = status.canSkipToPrevious\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SKIP_TO_NEXT -&gt; {\n                    // Change the look and feel of yor Next button here\n                    val canSkipToNext = status.canSkipToNext\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_PLAY_PAUSE -&gt; {\n                    // Change the look and feel of yor Play/Pause button here\n                    val canPlayPause = status.canPlayPause\n                    // ...\n                }\n                AutomixSDKStatusVariable.CAN_SEEK -&gt; {}\n                AutomixSDKStatusVariable.CAN_REORDER_TRACKS -&gt; {}\n                AutomixSDKStatusVariable.REPLAY_ON -&gt; {\n                    // Change the look and feel of yor Replay button here\n                    val replayOn = status.replayOn\n                    // ...\n                }\n                AutomixSDKStatusVariable.MUTED -&gt; {}\n                AutomixSDKStatusVariable.MASTER_TEMPO_NORMALISED -&gt; {}\n                AutomixSDKStatusVariable.NORMALISED_VOLUME -&gt; {}\n                AutomixSDKStatusVariable.REQUESTED_LOOP_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_INDEX_INTERNAL -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_CURRENT_TIME_INTERNAL -&gt; {}\n                AutomixSDKStatusVariable.CAN_BACK -&gt; {}\n                AutomixSDKStatusVariable.READY_TO_PLAY -&gt; {}\n                AutomixSDKStatusVariable.CAN_MIX_NOW -&gt; {}\n                AutomixSDKStatusVariable.PLAYLIST -&gt; {}\n                AutomixSDKStatusVariable.PLAY_SPEED -&gt; {}\n                AutomixSDKStatusVariable.PREFERRED_TRANSITION_DURATION_SECONDS -&gt; {}\n                AutomixSDKStatusVariable.REQUESTED_PAUSE_TRACK_IDENTIFIER -&gt; {}\n                AutomixSDKStatusVariable.VINYL_START_STOP -&gt; {}\n                AutomixSDKStatusVariable.NEXT_TRANSITION_DURATION -&gt; {}\n                AutomixSDKStatusVariable.TRANSITION_START_TIME_SECONDS -&gt; {}\n                AutomixSDKStatusVariable.FAILED_TRACK_LOAD_IDENTIFIERS -&gt; {}\n                AutomixSDKStatusVariable.CAN_ON_OFF -&gt; {}\n                AutomixSDKStatusVariable.PLAYING_TRACK_ORIGINAL_SESSION_ID -&gt; {}\n                AutomixSDKStatusVariable.MIX_ID -&gt; {}\n            }\n        }\n    }\n\n\n    // ...\n}\n</code></pre>"},{"location":"Update-ui/#receive-playback-events","title":"Receive playback events","text":"<p>To listen to playback events, implement the playbackEvent method.</p> <pre><code>public class MyPlayer: AutomixSDKStatusListener {\n    // ...\n\n    override fun playbackEvent(type: AutomixSDKPlaybackEventType, identifier: String?, originalSessionId: String?, status: AutomixSDKStatus?) {\n        when (type) {\n            AutomixSDKPlaybackEventType.trackPlayStart -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayPlayed5Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayHeartbeat30Secs -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlaySkipped -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayFinished -&gt; {}\n            AutomixSDKPlaybackEventType.mixPlaybackEnded -&gt; {}\n            AutomixSDKPlaybackEventType.trackPlayStartMixingIntoNext -&gt; {}\n        }\n    }\n\n    // ...\n}\n</code></pre> <p>The type of playback event is modelled by the enum AutomixSDKPlaybackEventType.</p>"},{"location":"Update-ui/#automix-status","title":"Automix Status","text":"<p>The status of AutomixIQ is modelled by AutomixSDKStatus. Find the documentation of available APIs here: AutomixIQ</p>"}]}